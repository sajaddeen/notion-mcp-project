import logger from "./logger.mjs";
import { addTraceProcessor } from "./tracing/index.mjs";
import { defaultProcessor } from "./tracing/processor.mjs";
import { getGlobalTraceProvider } from "./tracing/provider.mjs";
export { RuntimeEventEmitter } from '@openai/agents-core/_shims';
export { Agent, } from "./agent.mjs";
export { AgentsError, GuardrailExecutionError, InputGuardrailTripwireTriggered, MaxTurnsExceededError, ModelBehaviorError, OutputGuardrailTripwireTriggered, ToolCallError, UserError, SystemError, } from "./errors.mjs";
export { RunAgentUpdatedStreamEvent, RunRawModelStreamEvent, RunItemStreamEvent, } from "./events.mjs";
export { defineOutputGuardrail, } from "./guardrail.mjs";
export { getHandoff, getTransferMessage, Handoff, handoff, } from "./handoff.mjs";
export { assistant, system, user } from "./helpers/message.mjs";
export { extractAllTextOutput, RunHandoffCallItem, RunMessageOutputItem, RunReasoningItem, RunToolApprovalItem, RunToolCallItem, RunToolCallOutputItem, } from "./items.mjs";
export { AgentHooks } from "./lifecycle.mjs";
export { getLogger } from "./logger.mjs";
export { getAllMcpTools, invalidateServerToolsCache, MCPServerStdio, } from "./mcp.mjs";
export { setDefaultModelProvider } from "./providers.mjs";
export { RunResult, StreamedRunResult } from "./result.mjs";
export { run, Runner, } from "./run.mjs";
export { RunContext } from "./runContext.mjs";
export { RunState } from "./runState.mjs";
export { computerTool, tool, } from "./tool.mjs";
export * from "./tracing/index.mjs";
export { getGlobalTraceProvider, TraceProvider } from "./tracing/provider.mjs";
export { Usage } from "./usage.mjs";
export * as protocol from "./types/protocol.mjs";
/**
 * Add the default processor, which exports traces and spans to the backend in batches. You can
 * change the default behavior by either:
 * 1. calling addTraceProcessor, which adds additional processors, or
 * 2. calling setTraceProcessors, which sets the processors and discards the default one
 */
addTraceProcessor(defaultProcessor());
const cleanup = async () => {
    await getGlobalTraceProvider().shutdown();
};
if (typeof process !== 'undefined' && typeof process.on === 'function') {
    // handling Node.js process termination
    // Handle normal termination
    process.on('beforeExit', cleanup);
    // Handle CTRL+C (SIGINT)
    process.on('SIGINT', cleanup);
    // Handle termination (SIGTERM)
    process.on('SIGTERM', cleanup);
    process.on('unhandledRejection', (reason, promise) => {
        logger.error('Unhandled rejection', reason, promise);
        cleanup();
    });
}
//# sourceMappingURL=index.mjs.map